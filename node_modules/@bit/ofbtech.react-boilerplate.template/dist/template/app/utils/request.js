"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.request = request;
exports["default"] = void 0;

var _common = _interopRequireDefault(require("./common"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var BASE_URL_MAP = {
  DEFAULT: '{_apiUrl}'
};

var getBaseUrl = function getBaseUrl(server) {
  if (_common["default"].isUndefinedOrNullOrEmpty(server)) {
    return BASE_URL_MAP.DEFAULT;
  }

  return BASE_URL_MAP[server.toUpperCase()];
};
/**
 * Parses the JSON returned by a network request
 *
 * @param  {object} response A response from a network request
 *
 * @return {object}          The parsed JSON from the request
 */


function parseJSON(response) {
  try {
    return response.json();
  } catch (e) {
    var error = new Error(response.statusText);
    error.response = response;
    throw error;
  }
}
/**
 * Checks if a network request came back fine, and throws an error if not
 *
 * @param  {object} response   A response from a network request
 *
 * @return {object|undefined} Returns either the response, or throws an error
 */


function checkStatus(response) {
  if (response.success) {
    return response;
  }

  var error = new Error(response.errorMessage);
  error.response = response;
  throw error;
}
/**
 * Requests a URL, returning a promise
 *
 * @param  {string} url       The URL we want to request
 * @param  {object} [options] The options we want to pass to "fetch"
 *
 * @return {object}           The response data
 */


function request(url, options) {
  return fetch(url, options).then(parseJSON).then(checkStatus);
}

var getHeaders = function getHeaders(header, contentType) {
  var headers = {};
  headers['X-REFERRER-DOMAIN'] = '{_domain}';

  if (header) {
    headers = Object.assign(headers, header);
  }

  headers['Content-type'] = contentType || 'application/json';
  return headers;
};

var getDocHeaders = function getDocHeaders(header) {
  var headers = {};
  headers['X-REFERRER-DOMAIN'] = '{_domain}';

  if (header) {
    headers = Object.assign(headers, header);
  }

  return headers;
};

var _default = {
  get: function get(url, beServer, header) {
    return request(getBaseUrl(beServer) + url, {
      method: 'GET',
      headers: getHeaders(header)
    });
  },
  post: function post(url, data, beServer, contentType, header) {
    var body = data;

    if (contentType !== 'application/octet-stream') {
      body = JSON.stringify(data);
    }

    return request(getBaseUrl(beServer) + url, {
      method: 'POST',
      headers: getHeaders(header, contentType),
      body: body
    });
  },
  put: function put(url, data, beServer, header) {
    return request(getBaseUrl(beServer) + url, {
      method: 'PUT',
      headers: getHeaders(header),
      body: JSON.stringify(data)
    });
  },
  patch: function patch(url, data, beServer, header) {
    return request(getBaseUrl(beServer) + url, {
      method: 'PATCH',
      headers: getHeaders(header),
      body: JSON.stringify(data)
    });
  },
  "delete": function _delete(url, data, beServer, header) {
    return request(getBaseUrl(beServer) + url, {
      method: 'DELETE',
      headers: getHeaders(header),
      body: JSON.stringify(data)
    });
  },
  upload: function upload(url, data, progressCallback, beServer) {
    var headers = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
    return request(getBaseUrl(beServer) + url, {
      method: 'POST',
      headers: getDocHeaders(headers),
      body: data
    });
  }
};
exports["default"] = _default;

//# sourceMappingURL=request.js.map