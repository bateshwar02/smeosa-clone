"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

/**
 * This script is for internal usage.
 * It will run all generators in order to be able to lint them and detect
 * critical errors. Every generated component's name starts with 'RbGenerated'
 * and any modified file is backed up by a file with the same name but with the
 * 'rbgen' extension so it can be easily excluded from the test coverage reports.
 */
var chalk = require('chalk');

var nodePlop = require('node-plop');

var path = require('path');

var rimraf = require('rimraf');

var shell = require('shelljs');

var addCheckmark = require('./helpers/checkmark');

var xmark = require('./helpers/xmark');

process.chdir(path.join(__dirname, '../generators'));
var plop = nodePlop('./index.js');
var componentGen = plop.getGenerator('component');
var containerGen = plop.getGenerator('container');
/**
 * Every generated component/container is preceded by this
 * @type {string}
 */

var NAMESPACE = 'RbGenerated';
/**
 * Return a prettified string
 * @param {*} data
 * @returns {string}
 */

function prettyStringify(data) {
  return JSON.stringify(data, null, 2);
}
/**
 * Handle results from Plop
 * @param {array} changes
 * @param {array} failures
 * @returns {Promise<*>}
 */


function handleResult(_ref) {
  var changes = _ref.changes,
      failures = _ref.failures;
  return new Promise(function (resolve, reject) {
    if (Array.isArray(failures) && failures.length > 0) {
      reject(new Error(prettyStringify(failures)));
    }

    resolve(changes);
  });
}
/**
 * Feedback to user
 * @param {string} info
 * @returns {Function}
 */


function feedbackToUser(info) {
  return function (result) {
    console.info(chalk.blue(info));
    return result;
  };
}
/**
 * Report success
 * @param {string} message
 * @returns {Function}
 */


function reportSuccess(message) {
  return function (result) {
    addCheckmark(function () {
      return console.log(chalk.green(" ".concat(message)));
    });
    return result;
  };
}
/**
 * Report errors
 * @param {string} reason
 * @returns {Function}
 */


function reportErrors(reason) {
  // TODO Replace with our own helpers/log that is guaranteed to be blocking?
  xmark(function () {
    return console.error(chalk.red(" ".concat(reason)));
  });
  process.exit(1);
}
/**
 * Run eslint on all js files in the given directory
 * @param {string} relativePath
 * @returns {Promise<string>}
 */


function runLintingOnDirectory(relativePath) {
  return new Promise(function (resolve, reject) {
    shell.exec("npm run lint:eslint \"app/".concat(relativePath, "/**/**.js\""), {
      silent: true
    }, function (code) {
      return code ? reject(new Error("Linting error(s) in ".concat(relativePath))) : resolve(relativePath);
    });
  });
}
/**
 * Remove a directory
 * @param {string} relativePath
 * @returns {Promise<any>}
 */


function removeDir(relativePath) {
  return new Promise(function (resolve, reject) {
    try {
      rimraf(path.join(__dirname, '/../../app/', relativePath), function (err) {
        if (err) throw err;
      });
      resolve(relativePath);
    } catch (err) {
      reject(err);
    }
  });
}
/**
 * Test the component generator and rollback when successful
 * @param {string} name - Component name
 * @param {string} type - Plop Action type
 * @returns {Promise<string>} - Relative path to the generated component
 */


function generateComponent(_x) {
  return _generateComponent.apply(this, arguments);
}
/**
 * Test the container generator and rollback when successful
 * @param {string} name - Container name
 * @param {string} type - Plop Action type
 * @returns {Promise<string>} - Relative path to the generated container
 */


function _generateComponent() {
  _generateComponent = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee2(_ref2) {
    var name, memo, targetFolder, componentName, relativePath, component;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            name = _ref2.name, memo = _ref2.memo;
            targetFolder = 'components';
            componentName = "".concat(NAMESPACE, "Component").concat(name);
            relativePath = "".concat(targetFolder, "/").concat(componentName);
            component = "component/".concat(memo ? 'Pure' : 'NotPure');
            _context2.next = 7;
            return componentGen.runActions({
              name: componentName,
              memo: memo,
              wantMessages: true,
              wantLoadable: true
            }).then(handleResult).then(feedbackToUser("Generated '".concat(component, "'")))["catch"](function (reason) {
              return reportErrors(reason);
            });

          case 7:
            _context2.next = 9;
            return runLintingOnDirectory(relativePath).then(reportSuccess("Linting test passed for '".concat(component, "'")))["catch"](function (reason) {
              return reportErrors(reason);
            });

          case 9:
            _context2.next = 11;
            return removeDir(relativePath).then(feedbackToUser("Cleanup '".concat(component, "'")))["catch"](function (reason) {
              return reportErrors(reason);
            });

          case 11:
            return _context2.abrupt("return", component);

          case 12:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _generateComponent.apply(this, arguments);
}

function generateContainer(_x2) {
  return _generateContainer.apply(this, arguments);
}
/**
 * Generate components
 * @param {array} components
 * @returns {Promise<[string]>}
 */


function _generateContainer() {
  _generateContainer = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee3(_ref3) {
    var name, memo, targetFolder, componentName, relativePath, container;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            name = _ref3.name, memo = _ref3.memo;
            targetFolder = 'containers';
            componentName = "".concat(NAMESPACE, "Container").concat(name);
            relativePath = "".concat(targetFolder, "/").concat(componentName);
            container = "container/".concat(memo ? 'Pure' : 'NotPure');
            _context3.next = 7;
            return containerGen.runActions({
              name: componentName,
              memo: memo,
              wantHeaders: true,
              wantActionsAndReducer: true,
              wantSagas: true,
              wantMessages: true,
              wantLoadable: true
            }).then(handleResult).then(feedbackToUser("Generated '".concat(container, "'")))["catch"](function (reason) {
              return reportErrors(reason);
            });

          case 7:
            _context3.next = 9;
            return runLintingOnDirectory(relativePath).then(reportSuccess("Linting test passed for '".concat(container, "'")))["catch"](function (reason) {
              return reportErrors(reason);
            });

          case 9:
            _context3.next = 11;
            return removeDir(relativePath).then(feedbackToUser("Cleanup '".concat(container, "'")))["catch"](function (reason) {
              return reportErrors(reason);
            });

          case 11:
            return _context3.abrupt("return", container);

          case 12:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _generateContainer.apply(this, arguments);
}

function generateComponents(_x3) {
  return _generateComponents.apply(this, arguments);
}
/**
 * Run
 */


function _generateComponents() {
  _generateComponents = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee5(components) {
    var promises, results;
    return regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            promises = components.map(
            /*#__PURE__*/
            function () {
              var _ref5 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee4(component) {
                var result;
                return regeneratorRuntime.wrap(function _callee4$(_context4) {
                  while (1) {
                    switch (_context4.prev = _context4.next) {
                      case 0:
                        if (!(component.kind === 'component')) {
                          _context4.next = 6;
                          break;
                        }

                        _context4.next = 3;
                        return generateComponent(component);

                      case 3:
                        result = _context4.sent;
                        _context4.next = 10;
                        break;

                      case 6:
                        if (!(component.kind === 'container')) {
                          _context4.next = 10;
                          break;
                        }

                        _context4.next = 9;
                        return generateContainer(component);

                      case 9:
                        result = _context4.sent;

                      case 10:
                        return _context4.abrupt("return", result);

                      case 11:
                      case "end":
                        return _context4.stop();
                    }
                  }
                }, _callee4);
              }));

              return function (_x4) {
                return _ref5.apply(this, arguments);
              };
            }());
            _context5.next = 3;
            return Promise.all(promises);

          case 3:
            results = _context5.sent;
            return _context5.abrupt("return", results);

          case 5:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return _generateComponents.apply(this, arguments);
}

_asyncToGenerator(
/*#__PURE__*/
regeneratorRuntime.mark(function _callee() {
  return regeneratorRuntime.wrap(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return generateComponents([{
            kind: 'component',
            name: 'Component',
            memo: false
          }, {
            kind: 'component',
            name: 'MemoizedComponent',
            memo: true
          }, {
            kind: 'container',
            name: 'Container',
            memo: false
          }, {
            kind: 'container',
            name: 'MemoizedContainer',
            memo: true
          }])["catch"](function (reason) {
            return reportErrors(reason);
          });

        case 2:
        case "end":
          return _context.stop();
      }
    }
  }, _callee);
}))();

//# sourceMappingURL=generate-templates-for-linting.js.map